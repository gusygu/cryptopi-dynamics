(Optional) 3) Wire DB activity index after your status fetch

Where you already fetch server status (or any endpoint returning a useful activity metric), just push it into the poller:

// inside your existing fetchStatus() success branch
import { setDbActivity } from "@/lib/pollerClient";

// suppose the API returns { dbActivity: number } 0..100
const status = await res.json();
if (Number.isFinite(status?.dbActivity)) setDbActivity(status.dbActivity);

// also keep lastOkTs update where you already set it:
import { setLastOkTs } from "@/lib/pollerClient";
// setLastOkTs(gateTs)


If you don’t have a db index yet, we can derive a simple one temporarily:

dbActivity = clamp(100 - (avgFetchMs / 50) - errorPenalty); or expose it from your server /api/status.

Patch 3 — minimal wiring in page.tsx (use the component)

Keep the page lean: map VM → props, build availability with the helper, render.

// inside src/app/dynamics/page.tsx (or the relevant page)
// imports near top:
import DynamicsMatrix from "@/components/DynamicsMatrix";
import { deriveAvailability } from "@/lib/availability";

// ...inside your component after you have the VM data:
const coins = vm?.coins ?? data?.coins ?? [];                        // axis
const benchmark = vm?.matrix?.benchmark ?? data?.matrices?.benchmark;
const idp = vm?.matrix?.id_pct ?? data?.matrices?.id_pct;
const mea = vm?.matrix?.mea ?? meaGrid;                              // whichever you already have
const previewSymbols = vm?.preview?.symbols ?? null;                 // if available from preview route

const availability = useMemo(
  () => deriveAvailability(coins, benchmark, previewSymbols),
  [coins, benchmark, previewSymbols]
);

// ... in JSX where the matrix should render:
<DynamicsMatrix
  coins={coins}
  mea={mea}
  id_pct={idp}
  availability={availability}
  className="mt-3"
/>


Notes

The mapping is defensive (vm?.matrix vs data?.matrices) so it won’t crash if your VM shape uses matrix or matrices.

If you don’t have previewSymbols yet, the helper will use the benchmark grid heuristic so rings still show.


import AuxCards from "@/components/AuxCards";
import { toAuxCardsProps } from "@/lib/auxMapper";

// assume you already know the selected pairKey (e.g., `${Ca}-${Cb}`)
// and whether it’s available (from your preview pairs map)
const auxProps = toAuxCardsProps(vm, pairKey, pairs[pairKey]);

<AuxCards {...auxProps} className="mt-3" />,



Usage (where you render Market·Wallet·Histogram):

import { useWallets } from "@/lib/walletClient";
import WalletPanel from "@/components/WalletPanel";

// ...
const wallets = useWallets();
// assume you know current pair Ca, Cb:
<WalletPanel base={Ca} quote={Cb} wallets={wallets} className="mt-3" />


How to use

import AssetIdentityCard from "@/components/AssetIdentityCard";
import { useWallets } from "@/lib/walletClient";

// vm/matrices assumed already loaded in your page
const wallets = useWallets();

<AssetIdentityCard
  base={Ca}
  quote={Cb}
  bridge="USDT"
  coins={vm.coins}
  matrices={{ benchmark: vm.matrix.benchmark, id_pct: vm.matrix.id_pct, pct_drv: vm.matrix.pct_drv }}
  wallets={wallets}
  pct24h={vm.pct24h /* optional map: { BTC: 0.0123, ETH: -0.034 } */}
  histogram={{ edges: vm.histogram.edges, counts: vm.histogram.counts, nuclei: vm.histogram.nuclei }}
  className="mt-3"
/>


If you don’t have pct24h yet, you’ll still get the Market + Wallet + Histogram; the pct24h cells will show “—” until you pass them.